//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void MSP430InstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    357U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    350U,	// BUNDLE
    268435618U,	// ADC16mi
    570425506U,	// ADC16mm
    268435618U,	// ADC16mr
    285212834U,	// ADC16ri
    603979938U,	// ADC16rm
    285212834U,	// ADC16rr
    268435486U,	// ADC8mi
    570425374U,	// ADC8mm
    268435486U,	// ADC8mr
    285212702U,	// ADC8ri
    603979806U,	// ADC8rm
    285212702U,	// ADC8rr
    268435646U,	// ADD16mi
    570425534U,	// ADD16mm
    268435646U,	// ADD16mr
    285212862U,	// ADD16ri
    603979966U,	// ADD16rm
    805306678U,	// ADD16rm_POST
    285212862U,	// ADD16rr
    268435514U,	// ADD8mi
    570425402U,	// ADD8mm
    268435514U,	// ADD8mr
    285212730U,	// ADD8ri
    603979834U,	// ADD8rm
    805306630U,	// ADD8rm_POST
    285212730U,	// ADD8rr
    367U,	// ADJCALLSTACKDOWN
    507U,	// ADJCALLSTACKUP
    268435653U,	// AND16mi
    570425541U,	// AND16mm
    268435653U,	// AND16mr
    285212869U,	// AND16ri
    603979973U,	// AND16rm
    805306686U,	// AND16rm_POST
    285212869U,	// AND16rr
    268435521U,	// AND8mi
    570425409U,	// AND8mm
    268435521U,	// AND8mr
    285212737U,	// AND8ri
    603979841U,	// AND8rm
    805306638U,	// AND8rm_POST
    285212737U,	// AND8rr
    570425514U,	// BIC16mm
    268435626U,	// BIC16mr
    603979946U,	// BIC16rm
    285212842U,	// BIC16rr
    570425382U,	// BIC8mm
    268435494U,	// BIC8mr
    603979814U,	// BIC8rm
    285212710U,	// BIC8rr
    268435696U,	// BIT16mi
    570425584U,	// BIT16mm
    268435696U,	// BIT16mr
    1073742064U,	// BIT16ri
    1342177520U,	// BIT16rm
    1073742064U,	// BIT16rr
    268435549U,	// BIT8mi
    570425437U,	// BIT8mm
    268435549U,	// BIT8mr
    1073741917U,	// BIT8ri
    1342177373U,	// BIT8rm
    1073741917U,	// BIT8rr
    1711276156U,	// Bi
    1879048439U,	// Bm
    1744830711U,	// Br
    1711276145U,	// CALLi
    2147483761U,	// CALLm
    1711276145U,	// CALLr
    268435668U,	// CMP16mi
    268435668U,	// CMP16mr
    1073742036U,	// CMP16ri
    1342177492U,	// CMP16rm
    1073742036U,	// CMP16rr
    268435528U,	// CMP8mi
    268435528U,	// CMP8mr
    1073741896U,	// CMP8ri
    1342177352U,	// CMP8rm
    1073741896U,	// CMP8rr
    2415919632U,	// JCC
    2684354679U,	// JMP
    268435703U,	// MOV16mi
    570425591U,	// MOV16mm
    268435703U,	// MOV16mr
    1073742071U,	// MOV16ri
    1342177527U,	// MOV16rm
    436207958U,	// MOV16rm_POST
    1073742071U,	// MOV16rr
    268435556U,	// MOV8mi
    570425444U,	// MOV8mm
    268435556U,	// MOV8mr
    1073741924U,	// MOV8ri
    1342177380U,	// MOV8rm
    436207910U,	// MOV8rm_POST
    1073741924U,	// MOV8rr
    1342177380U,	// MOVZX16rm8
    1073741924U,	// MOVZX16rr8
    530U,	// NOP
    268435689U,	// OR16mi
    570425577U,	// OR16mm
    268435689U,	// OR16mr
    285212905U,	// OR16ri
    603980009U,	// OR16rm
    805306702U,	// OR16rm_POST
    285212905U,	// OR16rr
    268435542U,	// OR8mi
    570425430U,	// OR8mm
    268435542U,	// OR8mr
    285212758U,	// OR8ri
    603979862U,	// OR8rm
    805306654U,	// OR8rm_POST
    285212758U,	// OR8rr
    1711276251U,	// POP16r
    1711276236U,	// PUSH16r
    534U,	// RET
    523U,	// RETI
    1711276172U,	// SAR16r1
    1711276209U,	// SAR16r1c
    1711276040U,	// SAR8r1
    1711276077U,	// SAR8r1c
    268435610U,	// SBC16mi
    570425498U,	// SBC16mm
    268435610U,	// SBC16mr
    285212826U,	// SBC16ri
    603979930U,	// SBC16rm
    285212826U,	// SBC16rr
    268435478U,	// SBC8mi
    570425366U,	// SBC8mm
    268435478U,	// SBC8mr
    285212694U,	// SBC8ri
    603979798U,	// SBC8rm
    285212694U,	// SBC8rr
    1711276160U,	// SEXT16r
    1711276165U,	// SHL16r1
    1711276033U,	// SHL8r1
    268435603U,	// SUB16mi
    570425491U,	// SUB16mm
    268435603U,	// SUB16mr
    285212819U,	// SUB16ri
    603979923U,	// SUB16rm
    805306670U,	// SUB16rm_POST
    285212819U,	// SUB16rr
    268435471U,	// SUB8mi
    570425359U,	// SUB8mm
    268435471U,	// SUB8mr
    285212687U,	// SUB8ri
    603979791U,	// SUB8rm
    805306622U,	// SUB8rm_POST
    285212687U,	// SUB8rr
    1711276139U,	// SWPB16r
    430U,	// Select16
    490U,	// Select8
    400U,	// Shl16
    462U,	// Shl8
    385U,	// Sra16
    448U,	// Sra8
    415U,	// Srl16
    476U,	// Srl8
    268435682U,	// XOR16mi
    570425570U,	// XOR16mm
    268435682U,	// XOR16mr
    285212898U,	// XOR16ri
    603980002U,	// XOR16rm
    805306694U,	// XOR16rm_POST
    285212898U,	// XOR16rr
    268435535U,	// XOR8mi
    570425423U,	// XOR8mm
    268435535U,	// XOR8mr
    285212751U,	// XOR8ri
    603979855U,	// XOR8rm
    805306646U,	// XOR8rm_POST
    285212751U,	// XOR8rr
    1073741924U,	// ZEXT16r
    0U
  };

  const char AsmStrs[] = {
  /* 0 */ 'r', 'l', 'a', '.', 'b', 9, 0,
  /* 7 */ 'r', 'r', 'a', '.', 'b', 9, 0,
  /* 14 */ 's', 'u', 'b', '.', 'b', 9, 0,
  /* 21 */ 's', 'u', 'b', 'c', '.', 'b', 9, 0,
  /* 29 */ 'a', 'd', 'd', 'c', '.', 'b', 9, 0,
  /* 37 */ 'b', 'i', 'c', '.', 'b', 9, 0,
  /* 44 */ 'c', 'l', 'r', 'c', 10, 9, 'r', 'r', 'c', '.', 'b', 9, 0,
  /* 57 */ 'a', 'd', 'd', '.', 'b', 9, 0,
  /* 64 */ 'a', 'n', 'd', '.', 'b', 9, 0,
  /* 71 */ 'c', 'm', 'p', '.', 'b', 9, 0,
  /* 78 */ 'x', 'o', 'r', '.', 'b', 9, 0,
  /* 85 */ 'b', 'i', 's', '.', 'b', 9, 0,
  /* 92 */ 'b', 'i', 't', '.', 'b', 9, 0,
  /* 99 */ 'm', 'o', 'v', '.', 'b', 9, 0,
  /* 106 */ 's', 'w', 'p', 'b', 9, 0,
  /* 112 */ 'c', 'a', 'l', 'l', 9, 0,
  /* 118 */ 'j', 'm', 'p', 9, 0,
  /* 123 */ 'b', 'r', 9, 0,
  /* 127 */ 's', 'x', 't', 9, 0,
  /* 132 */ 'r', 'l', 'a', '.', 'w', 9, 0,
  /* 139 */ 'r', 'r', 'a', '.', 'w', 9, 0,
  /* 146 */ 's', 'u', 'b', '.', 'w', 9, 0,
  /* 153 */ 's', 'u', 'b', 'c', '.', 'w', 9, 0,
  /* 161 */ 'a', 'd', 'd', 'c', '.', 'w', 9, 0,
  /* 169 */ 'b', 'i', 'c', '.', 'w', 9, 0,
  /* 176 */ 'c', 'l', 'r', 'c', 10, 9, 'r', 'r', 'c', '.', 'w', 9, 0,
  /* 189 */ 'a', 'd', 'd', '.', 'w', 9, 0,
  /* 196 */ 'a', 'n', 'd', '.', 'w', 9, 0,
  /* 203 */ 'p', 'u', 's', 'h', '.', 'w', 9, 0,
  /* 211 */ 'c', 'm', 'p', '.', 'w', 9, 0,
  /* 218 */ 'p', 'o', 'p', '.', 'w', 9, 0,
  /* 225 */ 'x', 'o', 'r', '.', 'w', 9, 0,
  /* 232 */ 'b', 'i', 's', '.', 'w', 9, 0,
  /* 239 */ 'b', 'i', 't', '.', 'w', 9, 0,
  /* 246 */ 'm', 'o', 'v', '.', 'w', 9, 0,
  /* 253 */ 's', 'u', 'b', '.', 'b', 9, '@', 0,
  /* 261 */ 'a', 'd', 'd', '.', 'b', 9, '@', 0,
  /* 269 */ 'a', 'n', 'd', '.', 'b', 9, '@', 0,
  /* 277 */ 'x', 'o', 'r', '.', 'b', 9, '@', 0,
  /* 285 */ 'b', 'i', 's', '.', 'b', 9, '@', 0,
  /* 293 */ 'm', 'o', 'v', '.', 'b', 9, '@', 0,
  /* 301 */ 's', 'u', 'b', '.', 'w', 9, '@', 0,
  /* 309 */ 'a', 'd', 'd', '.', 'w', 9, '@', 0,
  /* 317 */ 'a', 'n', 'd', '.', 'w', 9, '@', 0,
  /* 325 */ 'x', 'o', 'r', '.', 'w', 9, '@', 0,
  /* 333 */ 'b', 'i', 's', '.', 'w', 9, '@', 0,
  /* 341 */ 'm', 'o', 'v', '.', 'w', 9, '@', 0,
  /* 349 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 356 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 366 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 0,
  /* 384 */ '#', 32, 'S', 'r', 'a', '1', '6', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 399 */ '#', 32, 'S', 'h', 'l', '1', '6', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 414 */ '#', 32, 'S', 'r', 'l', '1', '6', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 429 */ '#', 32, 'S', 'e', 'l', 'e', 'c', 't', '1', '6', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 447 */ '#', 32, 'S', 'r', 'a', '8', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 461 */ '#', 32, 'S', 'h', 'l', '8', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 475 */ '#', 32, 'S', 'r', 'l', '8', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 489 */ '#', 32, 'S', 'e', 'l', 'e', 'c', 't', '8', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 506 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 0,
  /* 522 */ 'r', 'e', 't', 'i', 0,
  /* 527 */ 'j', 0,
  /* 529 */ 'n', 'o', 'p', 0,
  /* 533 */ 'r', 'e', 't', 0,
  };

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 4 bits for 11 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, BUNDLE, ADJCALLSTACKDOWN, ADJCALLSTACKUP, NOP, RET, RETI, S...
    return;
    break;
  case 1:
    // ADC16mi, ADC16mr, ADC16ri, ADC16rr, ADC8mi, ADC8mr, ADC8ri, ADC8rr, AD...
    printOperand(MI, 2, O); 
    break;
  case 2:
    // ADC16mm, ADC16rm, ADC8mm, ADC8rm, ADD16mm, ADD16rm, ADD8mm, ADD8rm, AN...
    printSrcMemOperand(MI, 2, O); 
    O << ", "; 
    break;
  case 3:
    // ADD16rm_POST, ADD8rm_POST, AND16rm_POST, AND8rm_POST, OR16rm_POST, OR8...
    printOperand(MI, 3, O); 
    O << "+, "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // BIT16ri, BIT16rr, BIT8ri, BIT8rr, CMP16ri, CMP16rr, CMP8ri, CMP8rr, MO...
    printOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 5:
    // BIT16rm, BIT8rm, CMP16rm, CMP8rm, MOV16rm, MOV8rm, MOVZX16rm8
    printSrcMemOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 6:
    // Bi, Br, CALLi, CALLr, POP16r, PUSH16r, SAR16r1, SAR16r1c, SAR8r1, SAR8...
    printOperand(MI, 0, O); 
    break;
  case 7:
    // Bm
    printSrcMemOperand(MI, 0, O); 
    O << ", pc"; 
    return;
    break;
  case 8:
    // CALLm
    printSrcMemOperand(MI, 0, O, "mem"); 
    return;
    break;
  case 9:
    // JCC
    printCCOperand(MI, 1, O); 
    O << "\t"; 
    printPCRelImmOperand(MI, 0, O); 
    return;
    break;
  case 10:
    // JMP
    printPCRelImmOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 25) & 7) {
  default:   // unreachable.
  case 0:
    // ADC16mi, ADC16mr, ADC16ri, ADC16rr, ADC8mi, ADC8mr, ADC8ri, ADC8rr, AD...
    O << ", "; 
    break;
  case 1:
    // ADC16mm, ADC8mm, ADD16mm, ADD8mm, AND16mm, AND8mm, BIC16mm, BIC8mm, BI...
    printSrcMemOperand(MI, 0, O); 
    return;
    break;
  case 2:
    // ADC16rm, ADC8rm, ADD16rm, ADD8rm, AND16rm, AND8rm, BIC16rm, BIC8rm, OR...
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // Bi, CALLi, CALLr, POP16r, PUSH16r, SAR16r1, SAR16r1c, SAR8r1, SAR8r1c,...
    return;
    break;
  case 4:
    // Br
    O << ", pc"; 
    return;
    break;
  case 5:
    // MOV16rm_POST, MOV8rm_POST
    O << "+, "; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // ADC16ri, ADC16rr, ADC8ri, ADC8rr, ADD16ri, ADD16rr, ADD8ri, ADD8rr, AN...
    printOperand(MI, 0, O); 
    return;
  } else {
    // ADC16mi, ADC16mr, ADC8mi, ADC8mr, ADD16mi, ADD16mr, ADD8mi, ADD8mr, AN...
    printSrcMemOperand(MI, 0, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *MSP430InstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 33 && "Invalid register number!");

  static const char AsmStrs[] = {
  /* 0 */ 'r', '1', '0', 0,
  /* 4 */ 'r', '0', 0,
  /* 7 */ 'r', '1', '1', 0,
  /* 11 */ 'r', '1', 0,
  /* 14 */ 'r', '1', '2', 0,
  /* 18 */ 'r', '2', 0,
  /* 21 */ 'r', '1', '3', 0,
  /* 25 */ 'r', '3', 0,
  /* 28 */ 'r', '1', '4', 0,
  /* 32 */ 'r', '4', 0,
  /* 35 */ 'r', '1', '5', 0,
  /* 39 */ 'r', '5', 0,
  /* 42 */ 'r', '6', 0,
  /* 45 */ 'r', '7', 0,
  /* 48 */ 'r', '8', 0,
  /* 51 */ 'r', '9', 0,
  };

  static const unsigned RegAsmOffset[] = {
    25, 25, 32, 32, 4, 4, 39, 39, 42, 42, 45, 45, 48, 48, 
    51, 51, 0, 0, 7, 7, 14, 14, 21, 21, 28, 28, 35, 35, 
    11, 11, 18, 18, 
  };

  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

bool MSP430InstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
